package generate

import (
	"golang.org/x/text/cases"
	"golang.org/x/text/language"
	"log"
	"strconv"
	"strings"
	"text/template"
	"time"
)

func init() {
	var err error
	tmpl, err = template.New("enum").Funcs(template.FuncMap{
		"Now":                         func() string { return time.Now().Format(time.RFC3339) },
		"ToLower":                     strings.ToLower,
		"ToTitle":                     cases.Title(language.English, cases.Compact).String,
		"CommaSepNames":               joinNames(",", false),
		"CommaSepNamesOfUniqueValues": joinNames(", ", true),
		"ConcatNames":                 joinNames("", false),
		"CommaSepNameOffsets":         joinNameOffsets,
	}).Parse(tempCode)
	if err != nil {
		log.Fatalf("Failed to parse template: %v", err)
	}
}

var tmpl *template.Template

const tempCode = `
// Code generated by piteego/enums; DO NOT EDIT.
// Version: 1.0.0
// Executed At: {{Now}}

package {{.PackageName}}

import (
	"fmt"
)

const _{{.TypeName | ToLower}}_enum_names = "{{ConcatNames .Values}}"

var (
	_{{.TypeName | ToLower}}_enum_names_offsets = [...]uint8{0, {{CommaSepNameOffsets .Values}}}
	_{{.TypeName | ToLower}}_enum_name2index = map[string]{{.TypeName}}{
		{{range $i, $v := .Values}}{{if $i}}, {{end}}"{{$v.Name}}": {{$v.Value}}{{end}},
	}
)

func _() {
	var _x [1]struct{}
	{{range $i, $v := .Values}}_ = {{if ge $v.Value 0}}_x[{{$v.Name}}-{{$v.Value}}]{{else}}_x[{{$v.Name}}-({{$v.Value}})]{{end}}
	{{end}}// This function is used to generate an 'invalid array index' compiler error in case of 
	// any changes in the enum values. Re-run the code generation to fix this.
}

func {{ToTitle .TypeName}}List() []{{.TypeName}} {
	return []{{.TypeName}}{
		{{range $i, $v := .Values}}{{if $i}}, {{end}}{{$v.Value}}{{end}},
	}
}

func {{ToTitle .TypeName}}ListNames() []string {
	return []string{
		{{range $i, $v := .Values}}{{if $i}}, {{end}}"{{$v.Name}}"{{end}},
	}
}

func Parse{{ToTitle .TypeName}}(name string) {{.TypeName}} {
	if val, exists := _{{.TypeName | ToLower}}_enum_name2index[name]; exists {
		return val
	}
	return {{.TypeName}}(-1) // TODO: return minimum value minus one!
}

// Is checks if the {{.TypeName}} enum value is equal to the target {{.TypeName}} or any of the optional values.
func (x {{.TypeName}}) Is(target {{.TypeName}}, or ...{{.TypeName}}) bool {
	if x == target {
		return true
	}
	for i := range or {
		if x == or[i] {
			return true
		}
	}
	return false
}

// Validate validates the {{.TypeName}} enum value and returns an error if the value is not valid.
func (x {{.TypeName}}) Validate() error {
	switch x {
	case {{CommaSepNamesOfUniqueValues .Values}}:
		return nil

	default:
		return fmt.Errorf("invalid enum value: {{.PackageName}}.{{.TypeName}}(%d)", x)
	}
}

// IsValid true if the {{.TypeName}} enum value is valid.
func (x {{.TypeName}}) IsValid() bool {
	switch x {
	case {{CommaSepNamesOfUniqueValues .Values}}:
		return true
	}
	return false
}
`

// joinNames joins all enum value names using given separator
func joinNames(sep string, onlyUniqueValues bool) func([]constant) string {
	return func(constants []constant) string {
		names := make([]string, 0, len(constants))
		values := make(map[int64]struct{}, len(constants))
		for i := range constants {
			if onlyUniqueValues {
				if _, exists := values[constants[i].Value]; exists {
					continue
				}
				values[constants[i].Value] = struct{}{}
			}
			names = append(names, constants[i].Name)
		}
		return strings.Join(names, sep)
	}
}

// joinNameOffsets calculates and joins the byte offsets
func joinNameOffsets(values []constant) string {
	var offsets []string
	current := 0
	for _, v := range values {
		current += len(v.Name)
		offsets = append(offsets, strconv.Itoa(current))
	}
	return strings.Join(offsets, ", ")
}
